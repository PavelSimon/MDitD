# MDitD - N√°vrhy vylep≈°en√≠

Komprehenz√≠vna anal√Ωza k√≥dovej b√°zy s n√°vrhmi na zlep≈°enie v√Ωkonu, stability, bezpeƒçnosti a ƒçistoty k√≥du.

## üöÄ 1. Vylep≈°enia v√Ωkonu

### 1.1 Spr√°va pam√§te
**Probl√©m**: Cel√Ω obsah s√∫boru sa naƒç√≠tava do pam√§te naraz (`main.py:64`)
```python
file_content = await file.read()  # Problematick√© pre veƒæk√© s√∫bory
```

**Rie≈°enie**: Implementova≈• streaming upload pre veƒæk√© s√∫bory
```python
async def save_file_stream(file: UploadFile, file_path: str, chunk_size: int = 8192):
    """Streamova≈• s√∫bor na disk bez naƒç√≠tania do pam√§te."""
    with open(file_path, 'wb') as f:
        while chunk := await file.read(chunk_size):
            f.write(chunk)
```

### 1.2 Ch√Ωbaj√∫ce async/await optimaliz√°cie
**Probl√©m**: File oper√°cie v `utils/file_handler.py` s√∫ synchr√≥nne, blokuj√∫ event loop

**Rie≈°enie**: Pou≈æi≈• `aiofiles` pre async file oper√°cie
```bash
uv add aiofiles
```

```python
import aiofiles
import aiofiles.os

async def save_uploaded_file_async(self, file: UploadFile, filename: str) -> str:
    """Async verzia save_uploaded_file."""
    safe_filename = self._sanitize_filename(filename)
    file_path = self.uploads_dir / safe_filename
    
    counter = 1
    while await aiofiles.os.path.exists(file_path):
        name_part = Path(safe_filename).stem
        ext_part = Path(safe_filename).suffix
        new_filename = f"{name_part}_{counter}{ext_part}"
        file_path = self.uploads_dir / new_filename
        counter += 1
    
    async with aiofiles.open(file_path, 'wb') as f:
        async for chunk in file.stream():
            await f.write(chunk)
    
    return str(file_path)
```

### 1.3 Neefekt√≠vny loop spracovania s√∫borov
**Probl√©m**: S√∫bory sa spracov√°vaj√∫ sekvenƒçne

**Rie≈°enie**: Spracov√°va≈• s√∫bory concurrent
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

async def upload_files(files: List[UploadFile] = File(...)):
    with ThreadPoolExecutor(max_workers=min(4, len(files))) as executor:
        tasks = [
            asyncio.get_event_loop().run_in_executor(
                executor, process_single_file, file, output_dir
            ) for file in files
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)
    return format_results(results, files)
```

## üõ°Ô∏è 2. Vylep≈°enia stability

### 2.1 Ch√Ωba valid√°cia veƒækosti s√∫borov
**Probl√©m**: ≈Ωiadne limity na veƒækos≈• s√∫borov

**Rie≈°enie**: Prida≈• valid√°ciu veƒækosti
```python
# Kon≈°tanty
MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB
MAX_TOTAL_SIZE = 500 * 1024 * 1024  # 500MB

@app.post("/upload")
async def upload_files(files: List[UploadFile] = File(...)):
    # Validova≈• celkov√∫ veƒækos≈•
    total_size = sum(getattr(file, 'size', 0) for file in files)
    if total_size > MAX_TOTAL_SIZE:
        raise HTTPException(413, "Celkov√° veƒækos≈• s√∫borov presahuje limit")
    
    for file in files:
        if file.size and file.size > MAX_FILE_SIZE:
            raise HTTPException(413, f"S√∫bor {file.filename} presahuje limit veƒækosti")
```

### 2.2 Ne√∫pln√© error handling
**Probl√©m**: Generick√© exception handling maskuje ≈°pecifick√© chyby

**Rie≈°enie**: Implementova≈• ≈°pecifick√© exception handling
```python
try:
    # Konverzia logika
    pass
except FileNotFoundError:
    error = "Doƒçasn√Ω s√∫bor bol neoƒçak√°vane zmazan√Ω"
except PermissionError:
    error = "Odmietnut√Ω pr√≠stup k s√∫boru"
except OSError as e:
    error = f"Syst√©mov√° chyba: {e.strerror}"
except Exception as e:
    logger.exception(f"Neoƒçak√°van√° chyba pri spracovan√≠ {file.filename}")
    error = "Intern√° chyba servera"
```

### 2.3 Probl√©my s cleanup zdrojov
**Rie≈°enie**: Pou≈æi≈• context managery
```python
import contextlib

@contextlib.contextmanager
def temporary_file(content: bytes, filename: str):
    """Context manager pre doƒçasn√© s√∫bory."""
    temp_path = None
    try:
        temp_path = file_handler.save_uploaded_file(content, filename)
        yield temp_path
    finally:
        if temp_path and Path(temp_path).exists():
            file_handler.cleanup_temp_file(temp_path)
```

## üîí 3. Vylep≈°enia bezpeƒçnosti

### 3.1 Path traversal zraniteƒænosti
**Probl√©m**: Nedostatoƒçn√° sanitiz√°cia filename

**Rie≈°enie**: Posilni≈• filename sanitization
```python
import re

def _sanitize_filename(self, filename: str) -> str:
    """Vylep≈°en√° sanitiz√°cia filename."""
    filename = os.path.basename(filename)
    filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
    filename = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', filename)
    filename = filename.strip('. ')
    
    # Zabr√°ni≈• rezervovan√Ωm men√°m (Windows)
    reserved_names = {'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 
                     'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 
                     'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 
                     'LPT7', 'LPT8', 'LPT9'}
    
    name_without_ext = Path(filename).stem.upper()
    if name_without_ext in reserved_names:
        filename = f"file_{filename}"
    
    if len(filename) > 255:
        stem = Path(filename).stem[:200]
        suffix = Path(filename).suffix
        filename = f"{stem}{suffix}"
    
    return filename or "unnamed_file"
```

### 3.2 Ch√Ωba MIME type valid√°cia
**Rie≈°enie**: Prida≈• MIME type valid√°ciu
```python
import mimetypes

class DocumentConverter:
    def __init__(self):
        self.allowed_mime_types = {
            'application/pdf',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'text/html', 'text/csv', 'application/json', 'text/plain'
            # ... ƒèal≈°ie podporovan√© typy
        }
    
    async def validate_file_content(self, file: UploadFile) -> bool:
        """Validova≈• obsah s√∫boru podƒæa MIME typu."""
        detected_type = mimetypes.guess_type(file.filename)[0]
        return detected_type in self.allowed_mime_types
```

### 3.3 Output directory traversal
**Rie≈°enie**: Bezpeƒçn√° valid√°cia output path
```python
def create_output_path(self, original_filename: str, output_dir: Optional[str] = None) -> str:
    """Vytvori≈• bezpeƒçn√Ω output path."""
    if output_dir:
        target_dir = Path(output_dir).resolve()
        base_dir = Path.cwd().resolve()
        try:
            target_dir.relative_to(base_dir)
        except ValueError:
            raise ValueError(f"Output adres√°r mimo povolen√∫ cestu: {target_dir}")
    else:
        target_dir = self.output_dir.resolve()
    
    # Zvy≈°ok met√≥dy...
```

## üßπ 4. Vylep≈°enia ƒçistoty k√≥du

### 4.1 Ch√Ωbaj√∫ce type hints
**Rie≈°enie**: Prida≈• komprehenz√≠vne type hints
```python
from typing import List, Optional, Dict, Any

@app.post("/upload")
async def upload_files(
    files: List[UploadFile] = File(...),
    output_dir: Optional[str] = Form("vystup")
) -> Dict[str, Any]:
    """Upload a konverzia dokumentov do Markdown."""
    results: List[Dict[str, Any]] = []
    # ...
```

### 4.2 Magic numbers a ch√Ωbaj√∫ce kon≈°tanty
**Rie≈°enie**: Definova≈• kon≈°tanty v `config.py`
```python
# config.py
MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB
MAX_TOTAL_SIZE = 500 * 1024 * 1024  # 500MB
UPLOAD_CHUNK_SIZE = 8192
DEFAULT_UPLOADS_DIR = "uploads"
DEFAULT_OUTPUT_DIR = "vystup"
DEFAULT_HOST = "0.0.0.0"
DEFAULT_PORT = 8001

SUPPORTED_EXTENSIONS = {
    '.pdf', '.docx', '.pptx', '.xlsx', 
    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff',
    '.mp3', '.wav', '.m4a', '.flac',
    '.html', '.htm', '.csv', '.json', '.xml',
    '.zip', '.txt', '.md'
}
```

### 4.3 Ch√Ωbaj√∫ce docstrings
**Rie≈°enie**: ≈†tandardizova≈• docstrings
```python
def convert_to_file(self, input_path: str, output_path: str) -> Dict[str, Any]:
    """
    Konvertova≈• dokument a ulo≈æi≈• do s√∫boru.
    
    Args:
        input_path: Absol√∫tna cesta k vstupn√©mu dokumentu
        output_path: Absol√∫tna cesta kam sa ulo≈æ√≠ markdown s√∫bor
        
    Returns:
        Dictionary obsahuj√∫ci:
            - success (bool): ƒåi bola konverzia √∫spe≈°n√°
            - content (str|None): Konvertovan√Ω markdown obsah
            - error (str|None): Chybov√° spr√°va ak konverzia zlyhala
            - output_path (str|None): Cesta k ulo≈æen√©mu s√∫boru ak √∫spe≈°n√°
            
    Raises:
        OSError: Ak file system oper√°cie zlyhaj√∫
        PermissionError: Ak ch√Ωbaj√∫ opr√°vnenia na ƒç√≠tanie/z√°pis s√∫borov
    """
```

### 4.4 Probl√©m s logging konfigur√°ciou
**Rie≈°enie**: Centralizovan√° logging konfigur√°cia
```python
# logging_config.py
import logging
import sys

def setup_logging(log_level: str = "INFO", log_file: Optional[str] = None) -> None:
    """Konfigurova≈• aplikaƒçn√© logovanie."""
    formatter = logging.Formatter(
        fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, log_level.upper()))
    
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    root_logger.addHandler(console_handler)
    
    if log_file:
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(formatter)
        root_logger.addHandler(file_handler)
```

## ‚öôÔ∏è 5. ƒéal≈°ie odpor√∫ƒçania

### 5.1 Configuration management
**Rie≈°enie**: Pou≈æi≈• environment-based konfigur√°ciu
```python
# settings.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """Aplikaƒçn√© nastavenia s podporou environment variables."""
    host: str = "0.0.0.0"
    port: int = 8001
    reload: bool = True
    max_file_size: int = 100 * 1024 * 1024
    max_total_size: int = 500 * 1024 * 1024
    uploads_dir: str = "uploads"
    output_dir: str = "vystup"
    log_level: str = "INFO"
    
    class Config:
        env_file = ".env"

settings = Settings()
```

### 5.2 Vylep≈°en√Ω health check
```python
@app.get("/health")
async def health_check() -> Dict[str, Any]:
    """Vylep≈°en√Ω health check so system statusom."""
    return {
        "status": "healthy",
        "service": "MDitD",
        "version": "0.1.0",
        "timestamp": time.time(),
        "components": {
            "converter": converter_status,
            "filesystem": fs_status
        }
    }
```

### 5.3 Testing ≈°trukt√∫ra
**Rie≈°enie**: Prida≈• komprehenz√≠vne testy
```bash
uv add pytest pytest-asyncio httpx
mkdir tests
```

```python
# tests/test_converter.py
import pytest
from utils.converter import DocumentConverter

class TestDocumentConverter:
    @pytest.fixture
    def converter(self):
        return DocumentConverter()
    
    def test_supported_formats(self, converter):
        assert converter.is_supported_format("test.pdf")
        assert not converter.is_supported_format("test.exe")
```

## üìä S√∫hrn

### ‚úÖ IMPLEMENTOVAN√â (Krok 1 - Bezpeƒçnos≈•):
1. **‚úÖ Vylep≈°en√° filename sanitization** - Regex-based sanitization, kontrola rezervovan√Ωch mien, limit dƒ∫≈æky
2. **‚úÖ MIME type valid√°cia** - Valid√°cia na z√°klade MIME typu okrem extension check
3. **‚úÖ Bezpeƒçn√° output path valid√°cia** - Path traversal ochrana, relative path kontrola
4. **‚úÖ File size valid√°cia** - Limity 100MB/s√∫bor, 500MB celkovo
5. **‚úÖ Kon≈°tanty v config.py** - Centralizovan√© nastavenia

### ‚úÖ IMPLEMENTOVAN√â (Krok 2 - Stabilita):
1. **‚úÖ ≈†pecifick√© error handling** - Nahraden√© generic Exception s FileNotFoundError, PermissionError, OSError
2. **‚úÖ Resource cleanup s context managers** - Automatick√© ƒçistenie temporary files
3. **‚úÖ Vylep≈°en√© error messages** - Popisn√© chyby s podporovan√Ωmi form√°tmi a mo≈æn√Ωmi rie≈°eniami
4. **‚úÖ Roz≈°√≠ren√° input valid√°cia** - Valid√°cia poƒçtu s√∫borov, dƒ∫≈æky filename, zak√°zan√© znaky
5. **‚úÖ Testovan√© v≈°etky stability improvements** - Path traversal, multiple files, error conditions

### üîÑ ZOST√ÅVA IMPLEMENTOVA≈§:
3. **V√Ωkon**: Prida≈• async file handling a concurrent processing  
4. **Organiz√°cia k√≥du a dokument√°cia**

### Odpor√∫ƒçan√© poradie priority:
1. **‚úÖ Bezpeƒçnostn√© vylep≈°enia** - DOKONƒåEN√â
2. **‚úÖ Error handling a valid√°cia** - DOKONƒåEN√â
3. **üîÑ V√Ωkonov√© optimaliz√°cie**
4. **üîÑ Organiz√°cia k√≥du a dokument√°cia**

### Odhadovan√Ω zost√°vaj√∫ci ƒças implement√°cie:
- ~~Bezpeƒçnostn√© opravy: 1-2 dni~~ ‚úÖ DOKONƒåEN√â
- ~~Stability vylep≈°enia: 1 de≈à~~ ‚úÖ DOKONƒåEN√â
- V√Ωkonov√© vylep≈°enia: 2-3 dni
- Code cleanup: 1-2 dni  
- Testovanie: 1-2 dni (menej potrebn√© vƒèaka postupn√©mu testovaniu)

**Prv√© dve f√°zy (Bezpeƒçnos≈• a Stabilita) s√∫ kompletn√© a testovan√©!** Aplik√°cia m√° teraz v√Ωrazne lep≈°iu bezpeƒçnos≈•, error handling a resource management.